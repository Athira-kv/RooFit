import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from collections import defaultdict

# Function to calculate efficiency for each momentum bin
def calculate_efficiency_by_category(categories, momenta, N_ij, N_i):
    efficiencies_by_category = defaultdict(list)
    
    for cat in categories:
        for mom in momenta:
            N_i_value = N_i[(cat, mom)]  # Total N_i for category and momentum bin
            N_ij_value = N_ij[(cat, mom)]  # Corresponding N(i -> j) value
            efficiency = N_ij_value / N_i_value  # Calculate efficiency
            efficiencies_by_category[cat].append((mom, efficiency))
    
    return efficiency

# Function to calculate the error on the efficiency based on covariance matrix
def calculate_error_for_efficiency(efficiency, category, momentum, covariance_matrix, N_i, N_ij):
    # Calculate the derivative of efficiency with respect to N(i -> j)
    d_efficiency_d_N = lambda i, j: 1 / N_i[(category, momentum)]
    
    # Calculate the error using the formula provided
    error_squared = 0
    # Loop over all index combinations in the covariance matrix (i, j)
    for index1 in range(2, 10, 2):  # Indices: 2, 4, 6, 8
        for index2 in range(2, 10, 2):
            if index1 <= index2:  # Ensuring no double counting
                # Covariance between N(i -> j) and N(i -> k)
                u_value = covariance_matrix.get((index1, index2), 0)  # Get covariance value
                d_eff_d_N1 = d_efficiency_d_N(index1, index2)  # Derivative of efficiency wrt N(i -> j)
                error_squared += (d_eff_d_N1 ** 2) * u_value  # Error term
                
    return np.sqrt(error_squared)

def main():
    # Read the data from the input file
    data_file = 'k_covvalues.txt'  # Specify your input file
    data = pd.read_csv(data_file, sep ='\t', skiprows=1)
    
    # Define categories and momentum bins
    categories = data.iloc[:,0]
    momenta = data.iloc[:,1]
    n_as = data.iloc[:, 2]
    n_pi_s = data.iloc[:, 3]
    n_k_s = data.iloc[:, 4]
    n_p_s = data.iloc[:, 5]
    n_u_s = data.iloc[:, 6]

    # Create dictionaries for N_ij and N_i
    N_ij = defaultdict(float)
    N_i = defaultdict(float)
    
    for _, row in data.iterrows():
        category = row.iloc[0]
        momentum = row.iloc[1]
        
        # Assign N_ij based on the category
        if category == 0:
            N_ij_value = row.iloc[3]  # For category 0, use N_pi_s
        elif category == 1:
            N_ij_value = row.iloc[4]   # For category 1, use N_k_s
        elif category == 2:
            N_ij_value = row.iloc[5]   # For category 2, use N_p_s
        elif category == 3:
            N_ij_value = row.iloc[6]   # For category 4, use N_u_s
        elif category == 4:
            N_ij_value = row.iloc[2]
            
         # Store the values in the dictionaries
        N_ij[(category, momentum)] = N_ij_value
        N_i[(category, momentum)] = row.iloc[2]  # total events


    # Calculate efficiencies by category
    efficiencies_by_category = calculate_efficiency_by_category(categories, momenta, N_ij, N_i)
    print(f"Efficiency for Category {category} and Momentum {momentum}: {efficiencies_by_category}")
    
 
            
if __name__ == '__main__':
    main()
