#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <vector>
#include <TFile.h>
#include <TTree.h>
#include <TH1F.h>
#include <TCanvas.h>
#include <TGraph.h>
#include <TLegend.h>

void partials(double Ni, double Na, double &dNi){
  double part_der = (Na - Ni)/ (Na*Na) ;
  dNi = part_der;
}

double var_term(const std::vector<double>& dN, const std::vector<double>& v) {  
    double a = 0.0;
    for (size_t i = 0; i < dN.size(); ++i) {
        a += std::pow(dN[i], 2) * v[i];
    }
    return a;
}

double covar_term(const std::vector<double>& dN, const std::vector<std::vector<double>>& cv) {
    double a = 0.0;

    for (size_t i = 0; i < dN.size() - 1; ++i) {
        for (size_t j = i + 1; j < dN.size(); ++j) {
            a += dN[i] * dN[j] * cv[i][j];
        }
    }
    return a;
}

void create_covariance_matrix(const std::string& filename, std::vector<std::vector<double>>& cv, size_t max_index) {

  cv.resize(max_index + 1, std::vector<double>(max_index + 1, 0.0));

  std::ifstream file(filename);
  
  std::string line;
  int index1, index2;
  double value;
    
  std::getline(file, line);  // Assuming the first line is the header

  while (std::getline(file, line)) {
    std::istringstream ss(line);
    std::string temp;  // To store the extra columns
    // Skip the extra columns until we reach the last three columns
    for (int i = 0; i < 4; ++i) { // Skip first 4 columns (col1, col2, col3, col4)
      ss >> temp;  // Reading the extra columns into a temp string
    }
    
    if (ss >> index1 >> index2 >> value) {
      if (index1 >= 0 && index1 <= max_index && index2 >= 0 && index2 <= max_index) {
	cv[index1][index2] = value;
	cv[index2][index1] = value;
      }
    }
  }

    file.close();
}


void plot_efficiency() {

  std::ifstream infile("k_covvalues.txt");
    if (!infile.is_open()) {
        std::cerr << "Failed to open input file!" << std::endl;
        return;
    }

    // Variables to hold the data from the text file
    int category;
    double momentum, N_as, N_pi_s, N_k_s, N_p_s, N_u_s;
    
    // Create a map to store the efficiencies by category
    std::map<int, std::vector<std::pair<double, double>>> efficiencies_by_category;

    std::string line;
    std::getline(infile, line);


    // Read data from the text file
    while (std::getline(infile, line)) {
        std::stringstream ss(line);

	if (line.empty()) continue;

        // Parse each line assuming it's tab-separated (adjust delimiter if needed)
        ss >> category >> momentum >> N_as >> N_pi_s >> N_k_s >> N_p_s >> N_u_s;
	double efficiency = 0.0;
	if(category == 0){
	  efficiency = N_pi_s/N_as;
	}
	else if (category == 1){
	  efficiency = N_k_s/N_as;
	}
	else if (category == 2){
	  efficiency = N_p_s/N_as;
	}
	else if ( category == 3){
	  efficiency = N_u_s/N_as;
	}
	else if (category == 4){
	  efficiency = 1.0 ;
	}
	efficiencies_by_category[category].push_back(std::make_pair(momentum, efficiency));
    }

	
    // Close the input file
    infile.close();

    // Print efficiencies for debugging
    std::cout << "Efficiency values:" << std::endl;
    for (auto& entry : efficiencies_by_category) {
        int cat = entry.first;
        std::vector<std::pair<double, double>> mom_efficiencies = entry.second;
        std::cout << "Category " << cat << ":" << std::endl;
        for (const auto& pair : mom_efficiencies) {
            std::cout << "Momentum: " << pair.first << " | Efficiency: " << pair.second << std::endl;
        }
    }

    std::vector<std::vector<double>> cv;
    size_t max_index = 3;
    
    create_covariance_matrix("covariance_data.txt", cv, max_index);
        
    for (size_t i = 0; i <= max_index; ++i) {
      for (size_t j = 0; j <= max_index; ++j) {
	std::cout << cv[i][j] << " ";
      }
      std::cout << std::endl;
    }




    // Create a canvas for plotting
    TCanvas *canvas = new TCanvas("canvas", "Efficiency vs Momentum", 800, 600);

    // Create a legend for the plot
    TLegend *legend = new TLegend(0.7, 0.7, 0.9, 0.9);

    // Plot the efficiency vs momentum for each category
    for (auto& entry : efficiencies_by_category) {
        int cat = entry.first;
        std::vector<std::pair<double, double>> mom_efficiencies = entry.second;
        // Create vectors to hold momenta and efficiencies for plotting
        std::vector<double> momenta_vals;
        std::vector<double> efficiencies_vals;

        for (const auto& pair : mom_efficiencies) {
            momenta_vals.push_back(pair.first);
            efficiencies_vals.push_back(pair.second);
        }

        // Create a graph for the current category
        int npoints = momenta_vals.size();
        TGraph *graph = new TGraph(npoints, &momenta_vals[2], &efficiencies_vals[2]);

        graph->SetTitle(Form("Category %d", cat));
        graph->SetMarkerStyle(20 + cat);  // Different marker for each category
        //graph->SetMarkerColor(cat + 3);   // Different color for each category
        graph->SetLineColor(cat + 3);     // Same color for lines (if connected)

        // Draw the graph on the canvas
        if (cat == 0) {
            graph->Draw("AP");  // First graph, draw with axes
        } else {
            graph->Draw("P");   // Subsequent graphs, only plot points
        }

        // Add the category label to the legend
        legend->AddEntry(graph, Form("Category %d", cat), "p");

        // Clean up memory (graph will be automatically deleted at the end of the function)
    }

    // Add the legend to the canvas
    legend->Draw();

    // Show the canvas
    canvas->Update();
    canvas->Draw();
}    

